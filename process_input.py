# Alex Ramey (abr8xq)

# process_input.py is intended to serve as the middle layer in this solution.
# It accepts that list of teachers and the list of students generated by read_input.py,
# and does further processing before repeatedly invoking HopcroftKarp, the lowest
# layer, and maintaining the optimal solution.

from hopcroftkarp import HopcroftKarp
from read_input import Student, Teacher, readInStudentsFile, readInTeachersFile
from sys import maxsize
from math import floor
import itertools, copy, xlsxwriter, random

global g_best_solution

global g_students
global g_teachers
global g_original_teachers
global g_assignments
global g_assigned_cars
global g_unassigned_riders
global g_unassigned_cars
global g_schools_final_state
global g_teacher_assignments
global g_max_restriction
global g_max_restriction_2 # for the rerun, we may require a different degree of flexibility

"""
A car is identified by its driver. It has a capacity, list of riders, number
of seats left, and list of time_slot_ids that is initially equal to its driver's
list of availability. As riders are added, their availability is intersected with
the car's availability to determine the new availability.
"""
class Car:
    def __init__(self, driver):
        # constants . . .
        self.car_id = driver.student_id
        self.capacity = driver.num_passenger_seats + 1
        self.driver = driver

        # state variables . . .
        self.riders = []
        self.num_seats_left = self.capacity - 1
        self.time_slot_ids = set(driver.time_slot_ids)  # make a deep copy of the driver's set of time_slot_ids

    def add_rider(self, student):
        self.riders.append(student)
        self.num_seats_left -= 1
        self.time_slot_ids.intersection_update(student.time_slot_ids)

    def total_workers(self):
        return self.capacity - self.num_seats_left

    def __repr__(self):
        #return "\n" + self.car_id + ":" + str(len(self.riders)) + "/" + str(self.capacity) + ":" + str(self.riders) + ":" + str(list(self.time_slot_ids))
        return self.car_id + ":" + str(self.riders)

    def __eq__(self, other):
        if isinstance(other, Car):
            return (self.car_id == other.car_id)
        else:
            return False

    def __hash__(self):
        return hash(self.car_id)

"""
Strategy: Start with a set of empty cars and a set of unassigned riders. Place riders into cars they restrict the least.

A lower max_restriction value favors car flexibility at the expense of leaving some riders behind.
A higher max_restriction value favors packing in as many riders as possible at the expense of creating some
inflexible cars that may be harder to match in the next phase.

If no compatible cars exist, we iterate through all riders and see if swapping this rider with another rider
would restrict a car less. If so, we swap these two riders. If not, we add the rider to the no-ride set.
"""
def create_cars(students, max_restriction = 5, redistribute = True):
    global g_unassigned_riders

    eagles = []
    riders = []
    drivers = []

    for s in students:
        if (s.is_driver == True) and (s.num_passenger_seats == 0):
            eagles.append(s)
        elif s.is_driver == True:
            drivers.append(s)
        else:
            riders.append(s)
    #print("Eagles: " + str(len(eagles)) + ", Drivers: " + str(len(drivers)) + ", Riders: " + str(len(riders)))

    cars = []
    for d in drivers:
        cars.append(Car(d))

    # print(str(len(cars)))

    unassigned_riders = []
    assigned_riders = []

    # Order riders in ascending order based on # of time_slots
    riders.sort(key=lambda x: len(x.time_slot_ids), reverse=False)

    for r in riders:
        best_car = None
        lowest_restriction = maxsize
        for c in cars:
            if (c.num_seats_left > 0):
                restriction = compute_restriction(c,r,max_restriction)
                if  (((restriction < lowest_restriction) or ((restriction == lowest_restriction) and
                    (restriction != maxsize) and (c.num_seats_left > best_car.num_seats_left))) and
                    ((len(c.time_slot_ids) - restriction) > 0)):
                        best_car = c
                        lowest_restriction = restriction

        if best_car != None:
            best_car.add_rider(r)
            assigned_riders.append(r)
        else:
            unassigned_riders.append(r)

    #print("Number of Unassigned Riders: " + str(len(unassigned_riders)))
    #print("Unassigned Riders: " + str(unassigned_riders))
    #print(cars)
    if redistribute == True:                    # try to get each rider into a car
        successful_assignments = []
        for rider in unassigned_riders:
            result = reshuffle_cars(cars, [rider,])
            if result[1] == True:
                successful_assignments.append(rider)
                cars = result[0]

        unassigned_riders = set(unassigned_riders).difference_update(set(successful_assignments))
        if unassigned_riders == None:
            unassigned_riders = []
        else:
            unassigned_riders = list(unassigned_riders)

        #print("Successful Assignments: " + str(successful_assignments))
        #print("Unassigned Riders: " + str(unassigned_riders))

    # Track the unassigned riders
    g_unassigned_riders = unassigned_riders

    for e in eagles:
        cars.append(Car(e))

    return cars

"""
Given a car and student, determine how many time_slots this student would
remove from the car's availability if they were added as a rider.
If the restriction level is too high (greater than MAX_RESTRICTION)
return maxsize (indicating infinite restrction). Otherwise, return the actual
restriction value.
"""
def compute_restriction(car, student, max_restriction):
    num_removed_times = len(car.time_slot_ids) - len(car.time_slot_ids.intersection(student.time_slot_ids))

    if (num_removed_times <= max_restriction):
        return num_removed_times
    else:
        return maxsize

"""
Given the set of cars and a list of unassigned riders, we wish to iteratively
dump and re-add riders to try to arrive at some stable set of cars that
accomodates this new rider. If a satisfactory solution cannot be found,
we return the same set of cars that we passed in. Otherwise, we return the
new set of cars. The return value is a tuple (car_set, BOOL) where BOOL indicates
if we were successful in adding this new rider to some car.
"""
def reshuffle_cars(cars, riders):
    # deep copy so input cars remains unchanged in case of failure
    mutable_cars = copy.deepcopy(cars)

    # used to keep number of iterations reasonable before declaring failure
    loop_guard = 0

    # iteratively reshuffle the riders around the cars
    while (len(riders) > 0 and loop_guard < 100):
        loop_guard += 1
        assigned_riders = []
        newly_dumped_riders = []
        for r in riders:
            best_car = None
            best_dump_result = None
            for c in mutable_cars:
                result = compute_dump_count(r, c)
                if (result[0] != maxsize):
                    if (best_dump_result == None) or (result[0] < best_dump_result[0]):
                        best_car = c
                        best_dump_result = result
            if (best_car != None):
                for rider in best_car.riders:
                    if rider not in best_dump_result[1]:
                        newly_dumped_riders.append(rider) # kick out riders who aren't in the optimal subset by adding them to 'riders'
                # rebuild the car
                best_car.riders = []
                best_car.time_slot_ids = set(best_car.driver.time_slot_ids)
                best_car.num_seats_left = best_car.capacity - 1
                for rider in best_dump_result[1]:
                    best_car.add_rider(rider)
                best_car.add_rider(r)
                assigned_riders.append(r)
        for r in assigned_riders:
            riders.remove(r)
        for r in newly_dumped_riders:
            riders.append(r)

    if len(riders) > 0:
        return (cars, False)
    else:
        return (mutable_cars, True)

"""
Given a rider and a car, compute the minimum # of car_members
that would have to be kicked out to make the car compatible with
this new rider. If it's impossible (i.e. the driver isn't compatible
with this candidate rider), then return (maxsize, None). Else,
return (dump_count, optimal_set_of_riders_to_keep)
"""
def compute_dump_count(rider, car):
    common_times = rider.time_slot_ids.intersection(car.driver.time_slot_ids)

    if (len(common_times) == 0) or (car.capacity == 1):
        return (maxsize,None)           # impossible to add rider to this car

    else:
        if (len(car.riders) == 0):          # this car is empty, so no one has be kicked out
            return (0, [])

        if car.num_seats_left == 0:
            # we must evict at least one rider
            combo_size_cap = len(car.riders)
        else:
            # we may not need to evict anyone
            combo_size_cap = len(car.riders) + 1

        optimal_subset = []
        for L in range(0, combo_size_cap):
            for subset in itertools.combinations(car.riders, L):
                new_time_slot_ids = set(common_times)
                for rider in subset:
                    new_time_slot_ids.intersection_update(rider.time_slot_ids)
                if (len(new_time_slot_ids) > 0) and (len(subset) > len(optimal_subset)):
                    optimal_subset = subset

        # return (num_of_current_riders that we need to kick out, set of riders we want to keep)
        return ((car.total_workers() - 1) - len(optimal_subset), optimal_subset)

"""
The motivation for this function is the realization
that smaller cars are easier to match with work than larger cars.
This function works by trying to move riders from more full cars to
less full cars, considering flexibility when looking for the optimal
car to move a rider down to.
"""
def normalize_cars(cars, fuller_cars, count_to_deflate):
    # find candidate cars to receive riders from more full cars
    less_full_cars_with_extra_seat = []
    for c in cars:
        if ((c.total_workers() < (count_to_deflate - 1)) and (c.num_seats_left > 0)):
            less_full_cars_with_extra_seat.append(c)

    # try to move riders to less full cars
    successfully_deflated_cars = []
    for fc in fuller_cars:
        removed_riders = []
        for r in fc.riders:
            best_car = None
            lowest_restriction = maxsize
            for ec in less_full_cars_with_extra_seat:
                if (ec.num_seats_left > 0):
                    restriction = compute_restriction(ec,r,g_max_restriction)
                    if  (((restriction < lowest_restriction) or ((restriction == lowest_restriction) and
                        (restriction != maxsize) and (ec.total_workers() < best_car.total_workers()))) and
                        ((len(ec.time_slot_ids) - restriction) > 0)):
                            best_car = ec
                            lowest_restriction = restriction
            if best_car != None:
                best_car.add_rider(r)
                removed_riders.append(r)
                #print("Moved 1 Down!")
                if (not ((best_car.total_workers() < (count_to_deflate - 1)) and (best_car.num_seats_left > 0))):
                    less_full_cars_with_extra_seat.remove(best_car)

        # Now remove the riders from the fuller car that got reassigned . . .
        if (len(removed_riders) > 0):
            # rebuild this car . . .
            current_riders = list(fc.riders)
            fc.num_seats_left = fc.capacity - 1
            fc.riders = []
            fc.time_slot_ids = set(fc.driver.time_slot_ids)
            for r in current_riders:
                if (r not in removed_riders):
                    fc.add_rider(r)
            successfully_deflated_cars.append(fc)

    for df in successfully_deflated_cars:
        fuller_cars.remove(df)

    return fuller_cars



"""
A School is fundamentally a set of Teachers. A school has an id,
a list of its teachers, and a work dictionary. Work tracks available
work slots at a school. An entry 1 : 10 means that there are 10 slots
of work available at time 1. As cars get assigned to schools at specific
times, this dictionary is updated to reflect the number of remaining openings.
"""
class School:
    def __init__(self, school_id, teachers):
        self.school_id = school_id
        self.teachers = teachers
        self.work = self.compute_work()

    def compute_work(self):
        work = {}
        for teacher in self.teachers:
            for time in teacher.time_slot_ids:
                num_helpers_supported = self.compute_time_slot_capacity(teacher, time)
                if (num_helpers_supported > 0):
                    if time not in work:
                        work[time] = num_helpers_supported
                    else:
                        work[time] += num_helpers_supported
        return work

    """
    given a work-group with a size and list of available work times, return the
    subset of the input of times that this school could use this work_group.
    """
    def compute_work_slots(self, group_size, group_times):
        work_times = {}
        for w in group_times:
            if (w in self.work) and (self.work[w] >= group_size):
                work_times[w] = int(floor(self.work[w] / group_size))
        return work_times

    """
    The school is responsible for assigning the members of the car to
    teachers in the school. Once the assignments are complete, the school
    must update its work openings to take these assignments into account.
    If the car isn't able to be assigned at the given time, return False.
    On success, return True.
    """
    def assign_car_to_work_slot(self, car, time):
        global g_teacher_assignments
        eligible_teachers = {}      # map teachers to num_helper_supported at this time
        for teacher in self.teachers:
            num_helpers_supported = self.compute_time_slot_capacity(teacher,time)
            if (num_helpers_supported > 0):
                eligible_teachers[teacher] = num_helpers_supported

        # determine if it will be possible to assign this car
        workers = [car.driver,] + car.riders
        num_positions = 0
        for t in eligible_teachers:
            num_positions += eligible_teachers[t]
        if (num_positions < len(workers)):
            return False        # not enough positions to support this car

        # else, there are enough positions to support this car

        for w in workers:
            list_of_eligible_teachers = []
            for teacher in eligible_teachers:
                list_of_eligible_teachers.append(teacher)
            list_of_eligible_teachers.sort(key=lambda x: x.num_helpers_assigned, reverse=False)
            teacher = list_of_eligible_teachers[0]

            teacher.num_helpers_assigned += 1
            if time in teacher.assigned_time_slot_ids:
                teacher.assigned_time_slot_ids[time] += 1
            else:
                teacher.assigned_time_slot_ids[time] = 1

            eligible_teachers[teacher] -= 1
            if (eligible_teachers[teacher] == 0):
                del eligible_teachers[teacher]

            g_teacher_assignments[w] = teacher
            w.time_assignment = time
            w.car_assignment = car

        self.work = self.compute_work()

        return True

    """
    Given a teacher and a time, determine how many workers
    the teacher can take on at this time. Take into account
    the max_number of workers a teacher can have at once, the
    max_number they can have per week, and what their current
    assignments are.
    """
    def compute_time_slot_capacity(self, teacher, time):
        if (time not in teacher.time_slot_ids):
            return 0

        time_slot_capacity = teacher.max_num_helpers_at_once

        if (time in teacher.assigned_time_slot_ids):
            time_slot_capacity -= teacher.assigned_time_slot_ids[time]
        if (((time - 1) in teacher.assigned_time_slot_ids) and ((time + 1) not in teacher.assigned_time_slot_ids)):
            time_slot_capacity -= teacher.assigned_time_slot_ids[time - 1]
        elif (((time + 1) in teacher.assigned_time_slot_ids) and ((time - 1) not in teacher.assigned_time_slot_ids)):
            time_slot_capacity -= teacher.assigned_time_slot_ids[time + 1]
        elif (((time - 1) in teacher.assigned_time_slot_ids) and ((time + 1) in teacher.assigned_time_slot_ids)):
            time_slot_capacity -= max(teacher.assigned_time_slot_ids[time-1], teacher.assigned_time_slot_ids[time+1])

        return min(time_slot_capacity, teacher.max_num_helpers_per_week - teacher.num_helpers_assigned)

    def __repr__(self):
        return "\n" + self.school_id + str(self.teachers)

    def __eq__(self, other):
        if isinstance(other, School):
            return (self.school_id == other.school_id)
        else:
            return False

    def __hash__(self):
        return hash(self.school_id)

"""
Given cars, schools, and work_group_size, build the bipartite graph and
run HopcroftKarp to determine maximal matching between cars and school
work-blocks.
"""
def run_matching(cars, schools, size):
    global g_assignments
    global g_assigned_cars
    global g_unassigned_cars

    # determine the cars relevant for this round
    round_cars = []
    for c in cars:
        if c.total_workers() == size:
            round_cars.append(c)

    unmatched_cars = [] # keep track of these so we can normalize them later
    while (True):
        # get the set of worker_times for this round
        relevant_time_slots = set()
        for c in round_cars:
            relevant_time_slots.update(c.time_slot_ids)

        # Create a dictionary relating school_id to list of times where "size" workers are needed
        # by the school
        school_work_times = {}
        for s in schools:
            school_work_times[s.school_id] = s.compute_work_slots(size, relevant_time_slots)

        # Build bipartite graph. Column 1 is car_ids. Column 2 is school_id_slot#*task#.
        graph = {}
        for c in round_cars:
            list_of_compatible_work_blocks = []
            for school in school_work_times:
                for time in school_work_times[school]:
                    if time in c.time_slot_ids:
                        #list_of_compatible_work_blocks.append(school + "_" + str(time) + "*") # one work block for school of this size at each time
                        for i in range(0, school_work_times[school][time]):
                            list_of_compatible_work_blocks.append(school + "_" + str(time) + "*" + str(i + 1))
            if (len(list_of_compatible_work_blocks) > 0):
                graph[c.car_id] = list_of_compatible_work_blocks

        # determine the maximum matching between cars and schools
        result = HopcroftKarp(graph).maximum_matching()

        # Track matched and unmatched Cars
        unmatched_cars = []
        matched_cars = []
        for c in round_cars:
            if c.car_id not in result:
                unmatched_cars.append(c)
            else:
                matched_cars.append(c)

        if len(matched_cars) == 0:
            break

        # Attempt to do teacher_assignment for each car in the result
        unassigned_cars = []
        for c in matched_cars:
            school_block = result[c.car_id]
            school_id = school_block[:school_block.rfind('_')]
            time_slot = int(school_block[school_block.rfind('_') + 1 : school_block.rfind('*')])
            school = None
            for s in schools:
                if s.school_id == school_id:
                    school = s
                    break
            is_assignment_successful = school.assign_car_to_work_slot(c, time_slot)
            if (is_assignment_successful):
                g_assigned_cars.append(c)
                g_assignments[c.car_id] = school_block
            else:
                unassigned_cars.append(c)

        round_cars = unassigned_cars + unmatched_cars


    # try to push the unassigned cars down into lower rounds
    unmatched_cars = normalize_cars(cars, unmatched_cars, size)
    g_unassigned_cars += unmatched_cars

    # print("Car_Size: " + str(size))
    # print("Unassigned Cars:" + str(len(unassigned_cars)))
    # print(str(unassigned_cars))
    #if (size == 3):
       # print("Assigned Cars:" + str(len(assigned_cars)))
       # print(str(assigned_cars))
       # print(schools)
    #print(result)



"""
In this method, we first build all the School objects.
This is accomplished by grouping teachers by school, then intializing a new
School object with the school's name and list of teachers.

Then we find the size of the biggest car, and run our matching algorithm
for all car sizes, starting at the biggest, and working our way down to 1.
"""
def create_schools_and_iterate_through_car_sizes(cars, teachers):
    global g_unassigned_cars
    global g_unassigned_riders
    global g_schools_final_state

    schools = create_schools(teachers)

    # determine biggest car size
    biggest_car = 0
    for c in cars:
        if c.total_workers() > biggest_car:
            biggest_car = c.total_workers()

    # Run matching algorithm for all car sizes, starting with biggest cars first
    for i in range(biggest_car,0,-1):
        run_matching(cars, schools, i)

    # Experimentally run algorithm from scratch with remainder
    remaining_students = []
    remaining_students += g_unassigned_riders
    for c in g_unassigned_cars:
        remaining_students += c.riders
        remaining_students.append(c.driver)

    # reset these before matching again . . .
    g_unassigned_cars = []
    g_unassigned_riders = []

    cars = create_cars(remaining_students, g_max_restriction_2, False)

    # determine biggest car size
    biggest_car = 0
    for c in cars:
        if c.total_workers() > biggest_car:
            biggest_car = c.total_workers()

    # run matching algorithm biggest_car times. Run matching
    # algorithm for all car sizes, starting with biggest cars first
    for i in range(biggest_car,0,-1):
        run_matching(cars, schools, i)

    #END Experimental

    g_schools_final_state = schools

"""
Given set of teachers, return list of schools
"""
def create_schools(teachers = None):
    if teachers == None:
        return None

    teacher_sets = {}
    for t in teachers:
        if t.teacher_school in teacher_sets:
            teacher_sets[t.teacher_school].append(t)
        else:
            teacher_sets[t.teacher_school] = [t,]

    schools = []
    for school in teacher_sets:
        schools.append(School(school, teacher_sets[school]))

    return schools

"""
The purpose of this function is to verify that the result is feasible.
This includes checking the following:

1. Every car has enough seats for its workers.
2. Every student can work when they are assigned to work
3. The schools can support the worker they've been assigned
"""
def verify_feasibility_of_solution():
    schools = create_schools(g_original_teachers)
    for car in g_best_solution[1]:
        # check to see that car can carry all its passengers
        if (len(car.riders) > (car.capacity - 1)):
            return "NOT FEASIBLE - car is too full!"
        school_assignment = g_best_solution[0][car.car_id]
        school_id = school_assignment[:school_assignment.rfind('_')]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        # check to see that there's a job for all of these workers
        for s in schools:
            if (s.school_id == school_id):
                if not s.assign_car_to_work_slot(car, time_slot):
                    return "NOT FEASIBLE - school cannot support work assignment!"
        # check to see that all the members of a car can work when they're assigned to
        for r in car.riders:
            if time_slot not in r.time_slot_ids:
                return "NOT FEASIBLE - rider cannot work then"
            if time_slot not in car.driver.time_slot_ids:
                return "NOT FEASIBLE - driver cannot work then"
    # passed all checks
    return "Feasibility Verified!"

"""
The purpose of this function is to write the results to an excel workbook.
"""
def write_results_to_excel_workbook():
    workbook = xlsxwriter.Workbook('Schedule.xlsx')
    bold = workbook.add_format({'bold': True})

    cars = g_best_solution[1]

    students_worksheet = workbook.add_worksheet('Assignments')
    cols = ['student_id', 'car_id', 'start_time', 'school_id', 'teacher_email', 'teacher_room']
    for i,val in enumerate(cols):
        students_worksheet.write(0,i,val, bold)
    row_counter = 1
    for c in cars:
        school_assignment = g_best_solution[0][c.car_id]
        school_id = school_assignment[:school_assignment.rfind('_')]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        workers = [c.driver,] + c.riders
        for w in workers:
            values = [w.student_id, c.car_id, extract_readable_start_time(time_slot), school_id, g_best_solution[5][w].email, g_best_solution[5][w].room_number]
            for i,val in enumerate(values):
                students_worksheet.write(row_counter,i,val)
            row_counter += 1

    cars_worksheet = workbook.add_worksheet('Cars')
    cols = ['driver_id', 'riders', 'start_time', 'school', 'seats_remaining']
    for i,val in enumerate(cols):
        cars_worksheet.write(0,i,val,bold)
    row_counter = 1
    for c in cars:
        school_assignment = g_best_solution[0][c.car_id]
        school_id = school_assignment[:school_assignment.rfind('_')]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        values = [c.car_id,str(c.riders),extract_readable_start_time(time_slot), school_id, c.num_seats_left]
        for i,val in enumerate(values):
            cars_worksheet.write(row_counter,i,val)
        row_counter += 1

    teachers_worksheet = workbook.add_worksheet('Teachers Assigned')
    cols = ['teacher_email', 'start_time', 'student_id(s)']
    for i,val in enumerate(cols):
        teachers_worksheet.write(0,i,val,bold)
    row_counter = 1

    teacher_helpers = {}    # map teachers to dictionaries of {time_slot : helpers}
    for worker in g_best_solution[5]:
        t = g_best_solution[5][worker]
        if t not in teacher_helpers:
            teacher_helpers[t] = {}

        # find what time this student works
        time_slot = worker.time_assignment
        if time_slot in teacher_helpers[t]:
            teacher_helpers[t][time_slot].append(worker.student_id)
        else:
            teacher_helpers[t][time_slot] = [worker.student_id, ]

    for t in teacher_helpers:
        for time_slot in teacher_helpers[t]:
            values = [t.email, extract_readable_start_time(time_slot), str(teacher_helpers[t][time_slot])]
            for i,val in enumerate(values):
                teachers_worksheet.write(row_counter, i, val)
            row_counter += 1

    unassigned_worksheet = workbook.add_worksheet('Unassigned_Workers')
    cols = ['student_id', 'is_driver', 'work_times']
    for i,val in enumerate(cols):
        unassigned_worksheet.write(0,i,val,bold)
    row_counter = 1

    unassigned_workers = []
    for c in g_best_solution[2]:
        unassigned_workers.append(c.driver)
        unassigned_workers += c.riders
    unassigned_workers += g_best_solution[3]

    for w in unassigned_workers:
        readable_time_slots = []
        for time_slot in w.time_slot_ids:
            readable_time_slots.append(extract_readable_start_time(time_slot))
        values = [w.student_id, w.is_driver, str(readable_time_slots)]
        for i,val in enumerate(values):
            unassigned_worksheet.write(row_counter,i,val)
        row_counter += 1

    available_work_worksheet = workbook.add_worksheet('Unassigned_Work')
    cols = ['school_id', 'start_time', 'num_positions']
    for i,val in enumerate(cols):
        available_work_worksheet.write(0,i,val,bold)
    row_counter = 1

    for school in g_best_solution[6]:
        for time in school.work:
            if school.work[time] > 0:
                available_work_worksheet.write(row_counter, 0, school.school_id)
                available_work_worksheet.write(row_counter, 1, extract_readable_start_time(time))
                available_work_worksheet.write(row_counter, 2, str(school.work[time]))
                row_counter += 1

    available_slots_worksheet = workbook.add_worksheet('Unassigned_Teacher_Slots')
    cols = ['teacher_email', 'school_id', 'num_helpers_assigned', 'max_num_helpers_per_week', 'max_num_helpers_at_once' 'unassigned_slots [slot*capacity_for_this_slot, . . .]']
    for i,val in enumerate(cols):
        available_slots_worksheet.write(0,i,val,bold)
    row_counter = 1

    utility = School("temp", [])
    for t in g_best_solution[7]:
        all_time_slots = {} # dictionary mapping time slot to # of workers a teacher can still support at this time
        for time_slot in t.time_slot_ids:
            num_helpers_supported = utility.compute_time_slot_capacity(t, time_slot)
            if (num_helpers_supported > 0):
                all_time_slots[time_slot] = num_helpers_supported
        readable_remaining_time_slots = []
        for time_slot in all_time_slots:
            readable_remaining_time_slots.append(extract_readable_start_time(time_slot) + "*" + str(all_time_slots[time_slot]))
        values = [t.email, t.teacher_school, t.num_helpers_assigned, t.max_num_helpers_per_week, t.max_num_helpers_at_once, str(readable_remaining_time_slots)]
        for i,val in enumerate(values):
            available_slots_worksheet.write(row_counter, i, val)
        row_counter += 1

    workbook.close()

"""
The purpose of this function is to convert a time_slot_id
back into a human-readable time like 'Monday 10:30 a.m.'
"""
def extract_readable_start_time(time_slot):
    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    day_index = int(time_slot/48)
    hour = (time_slot%48) # time_slot could be 0 through 238
    token_one = days[day_index]

    token_two = ''
    hr_output = 0
    if hour > 23:
        hour_output = int((hour - 24) / 2)
    else:
        hour_output = int(hour/2)
    if (hour_output == 0):
        hour_output = 12
    token_two = str(hour_output)

    token_three = ''
    if (hour%2) == 0:
        token_three = ':00'
    else:
        token_three = ':30'

    token_four = ''
    if hour > 23:
        token_four = 'p.m.'
    else:
        token_four = 'a.m.'

    return token_one + ' ' + token_two + token_three + token_four

if __name__ == '__main__':
    global g_students
    global g_teachers
    global g_original_teachers
    global g_assignments
    global g_assigned_cars
    global g_unassigned_cars
    global g_teacher_assignments
    global g_max_restriction
    global g_max_restriction_2
    global g_best_solution
    g_best_solution = None
    # looping was here
    g_original_teachers = None
    for i in range(10,21):
        for j in range(1,6):
            for k in range(0,5):
                g_assignments = {}
                g_teacher_assignments = {}
                g_unassigned_cars = []
                g_assigned_cars = []
                g_students = readInStudentsFile()
                g_teachers = readInTeachersFile()
                if g_original_teachers == None:
                    g_original_teachers = copy.deepcopy(g_teachers)
                g_max_restriction = i
                g_max_restriction_2 = j
                create_schools_and_iterate_through_car_sizes(create_cars(g_students, g_max_restriction), g_teachers)
                #print("# Unassigned Riders: " + str(len(g_unassigned_riders)))
                #print("# Unassigned Cars: " + str(len(g_unassigned_cars)))
                count = 0
                for c in g_assigned_cars:
                    count += c.total_workers()
                #print("# Assigned Workers: " + str(count))
                count = 0
                for c in g_unassigned_cars:
                    count += c.total_workers()
                #print("# Unassigned Workers: " + str(count))
                #print("# Assigned Cars: " + str(len(g_assignments)))
                #print("Assignments: " + str(g_assignments))
                #print("Cars: " + str(g_assigned_cars))
                if (g_best_solution == None) or ((count + len(g_unassigned_riders)) < g_best_solution[4]):
                    g_best_solution = (copy.deepcopy(g_assignments), copy.deepcopy(g_assigned_cars), copy.deepcopy(g_unassigned_cars), copy.deepcopy(g_unassigned_riders), count + len(g_unassigned_riders), copy.deepcopy(g_teacher_assignments), copy.deepcopy(g_schools_final_state), copy.deepcopy(g_teachers))
                    #print(str(i) + "," + str(j) + "," + str(count + len(g_unassigned_riders)))
    print(verify_feasibility_of_solution())
    write_results_to_excel_workbook()