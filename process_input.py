# Alex Ramey (abr8xq)

# process_input.py is intended to serve as the middle layer in this solution.
# It accepts that list of teachers and the list of students generated by read_input.py,
# and does further processing before repeatedly invoking HopcroftKarp, the lowest
# layer, and keep track of the optimal solutions.

from hopcroftkarp import HopcroftKarp
from read_input import Student, Teacher, readInStudentsFile, readInTeachersFile
from sys import maxsize
from math import floor
import itertools, copy, xlsxwriter, random

global g_best_solution

global g_students
global g_teachers
global g_assignments
global g_assigned_cars
global g_unassigned_riders
global g_unassigned_cars
global g_schools_final_state
global g_MAX_RESTRICTION
global g_MAX_RESTRICTION_V2 # for the rerun, we may require a different degree of flexibility

"""
A car is identified by its driver. It has a capacity, list of riders, number
of seats left, and list of time_slot_ids that is initially equal to its driver's
list of availability. As riders are added, their availability is intersected with
the car's availability to determine the new availability.
"""
class Car:
    def __init__(self, driver):
        # constants . . .
        self.car_id = driver.student_id
        self.capacity = driver.num_seats    # doesn't include the driver
        self.driver = driver
        # state variables . . .
        self.riders = []
        self.num_seats_left = self.capacity
        self.time_slot_ids = set(driver.time_slot_ids)

    def add_rider(self, student):
        self.riders.append(student)
        self.num_seats_left -= 1
        self.time_slot_ids = self.time_slot_ids.intersection(set(student.time_slot_ids))

    def total_workers(self):
        return self.capacity - self.num_seats_left + 1

    def __repr__(self):
        #return "\n" + self.car_id + ":" + str(len(self.riders)) + "/" + str(self.capacity) + ":" + str(self.riders) + ":" + str(list(self.time_slot_ids))
        return self.car_id + ":" + str(self.riders)

    def __eq__(self, other):
        if isinstance(other, Car):
            return (self.car_id == other.car_id)
        else:
            return False

    def __hash__(self):
        return hash(self.car_id)

"""
Strategy: Start with a set of empty cars and a set of unassigned riders. Place riders into cars they restrict the least.
A car's working time set may never drop below cardinality min(MAX_RESTRICTION,inital size of driver's working time set),
so we can not add a rider to a car that would violate this.

A higher MAX_RESTRICTION value favors car flexibility at the expense of leaving some riders behind.
A lower MAX_RESTRICTION value favor packing in as many riders as possible at the expense of creating some
inflexible cars that may be harder to match in the next phase.

If no compatible cars exist, we iterate through all riders and see if swapping this rider with any given
rider would restrict a car less. If so, we swap these two riders. If not, we add the rider to the no-ride set.
"""
def create_cars(students, MAX_RESTRICTION = 5, redistribute = True):
    global g_unassigned_riders

    eagles = []
    riders = []
    drivers = []

    for s in students:
        if s.is_driver == True and s.num_seats == 0:
            eagles.append(s)
        elif s.is_driver == True:
            drivers.append(s)
        else:
            riders.append(s)
    #print("Eagles: " + str(len(eagles)) + ", Drivers: " + str(len(drivers)) + ", Riders: " + str(len(riders)))

    cars = []
    for d in drivers:
        cars.append(Car(d))

    # print(str(len(cars)))

    unassigned_riders = []
    assigned_riders = []

    # Order rider in ascending order based on # of time_slots
    riders.sort(key=lambda x: len(x.time_slot_ids), reverse=False)

    for r in riders:
        best_car = None
        lowest_restriction = maxsize
        for c in cars:
            restriction = compute_restriction(c,r,MAX_RESTRICTION)
            if restriction <= lowest_restriction and restriction != maxsize:
                if (not ((restriction == lowest_restriction) and (best_car.num_seats_left >= c.num_seats_left))):
                    lowest_restriction = restriction
                    best_car = c

        if best_car != None:
            best_car.add_rider(r)
            assigned_riders.append(r)
        else:
            unassigned_riders.append(r)

    #print("Number of Unassigned Riders: " + str(len(unassigned_riders)))
    #print("Unassigned Riders: " + str(unassigned_riders))
    #print(cars)
    if redistribute == True:
        # try to get each rider into a car
        successful_assignments = []
        for rider in unassigned_riders:
            result = reshuffle_cars(cars, [rider,])
            if result[1] == True:
                successful_assignments.append(rider)
                cars = result[0]

        unassigned_riders = set(unassigned_riders).difference_update(set(successful_assignments))
        if unassigned_riders == None:
            unassigned_riders = []
        else:
            unassigned_riders = list(unassigned_riders)

        #print("Successful Assignments: " + str(successful_assignments))
        #print("Unassigned Riders: " + str(unassigned_riders))

    # Track the unassigned riders
    g_unassigned_riders = unassigned_riders

    for e in eagles:
        cars.append(Car(e))

    return cars

"""
Given a car, student, and MAX_RESTRICTION value, determine how many time_slots
this student would remove from the car's availability if they were added as a rider.
If the restriction level is too high or the car is already full, return maxsize
(indicating infinite restrction). Otherwise, return the actual restriction value.
"""
def compute_restriction(car, student, MAX_RESTRICTION):
    MAX_RESTRICTION = min(MAX_RESTRICTION, len(car.time_slot_ids))
    restriction = len(car.time_slot_ids) - len(car.time_slot_ids.intersection(set(student.time_slot_ids)))

    if ((len(car.time_slot_ids) - restriction) < MAX_RESTRICTION) or (car.num_seats_left == 0):
        return maxsize
    else:
        return restriction

"""
Given the set of cars and some unassigned rider, we wish to iteratively
dump and re-add riders to try to arrive at some stable set of cars that
accomodates this new rider. If a satisfactory solution cannot be found,
we return the same set of cars that we passed in. Otherwise, we return the
new set of cars. The return value is a tuple (car_set, BOOL) where BOOL indicates
if we were successful in adding this new rider.
"""
def reshuffle_cars(cars, riders):
    # copy the input to return in the case of failure
    mutable_cars = copy.deepcopy(cars)

    # used to keep number of iterations reasonable before declaring failure
    loop_guard = 0

    # iteratively reshuffle the riders around the cars
    while (len(riders) > 0 and loop_guard < 100):
        loop_guard += 1
        assigned_riders = []
        newly_dumped_riders = []
        for r in riders:
            best_car = None
            best_dump_result = None
            for c in mutable_cars:
                result = compute_dump_count(r, c)
                if (result[0] != maxsize):
                    if (best_dump_result == None) or (result[0] < best_dump_result[0]):
                        best_car = c
                        best_dump_result = result
            if (best_car != None):
                for rider in best_car.riders:
                    if rider not in best_dump_result[1]:
                        newly_dumped_riders.append(rider) # kick out riders who aren't in the optimal subset by adding them to 'riders'
                # rebuild the car
                best_car.riders = []
                best_car.time_slot_ids = set(best_car.driver.time_slot_ids)
                best_car.num_seats_left = best_car.capacity
                for rider in best_dump_result[1]:
                    best_car.add_rider(rider)
                best_car.add_rider(r)
                assigned_riders.append(r)
        for r in assigned_riders:
            riders.remove(r)
        for r in newly_dumped_riders:
            riders.append(r)

    if len(riders) > 0:
        return (cars, False)
    else:
        return (mutable_cars, True)

"""
Given a rider and a car, compute the # of car_members
that would have to be kicked out to make the car compatible with
this new rider. If it's impossible (i.e. the driver isn't compatible
with this candidate rider), then return (maxsize, None). Else,
return (dump_count, optimal_set_of_riders_to_keep)
"""
def compute_dump_count(rider, car):
    common_times = set(rider.time_slot_ids).intersection(car.time_slot_ids)

    if (len(common_times) == 0) or (car.capacity == 0):
        return (maxsize,None)         # impossible to add rider to this car

    else:
        riders = list(car.riders)
        if (len(riders) == 0):      # this car is empty, so no one has be kicked out
            return (0, [])

        if car.num_seats_left == 0:
            # we must evict at least one rider
            combo_size_cap = len(riders)
        else:
            # we may not need to evict anyone
            combo_size_cap = len(riders) + 1

        optimal_subset = []
        for L in range(0, combo_size_cap):
            for subset in itertools.combinations(riders, L):
                new_time_slot_ids = set(common_times)
                for rider in subset:
                    new_time_slot_ids.intersection_update(set(rider.time_slot_ids))
                    if (len(new_time_slot_ids) > 0) and (len(subset) > len(optimal_subset)):
                        optimal_subset = subset

        # return (num_of_current_riders that we need to kick out, set of riders we want to keep)
        return ((car.capacity - car.num_seats_left) - len(optimal_subset), optimal_subset)

"""
This function's purpose is to take in a set of cars, spread
the riders across the cars as evenly as possible, and return
the result. The motivation for this function is the realization
that smaller cars are easier to match with work than larger cars.

This function works by trying to move riders from more full cars to
less full cars. It considers flexibilities as well, and finishes when
it can find no more favorable moves.
"""
def normalize_cars(cars, fuller_cars, count_to_deflate):
    ret_val = fuller_cars
    # split up the cars into two sets
    less_full_cars_with_extra_seat = []
    for c in cars:
        if (c.total_workers() <= count_to_deflate-2) and (c.num_seats_left > 0):
            less_full_cars_with_extra_seat.append(c)

    # try to move riders to less full cars
    for fc in fuller_cars:
        removed_riders = []
        for r in fc.riders:
            best_car = None
            lowest_restriction = maxsize
            for ec in less_full_cars_with_extra_seat:
                restriction = compute_restriction(ec,r,g_MAX_RESTRICTION)
                if restriction <= lowest_restriction and restriction != maxsize:
                    if (not ((restriction == lowest_restriction) and (best_car.total_workers() <= ec.total_workers()))):
                        lowest_restriction = restriction
                        best_car = ec
            if best_car != None:
                best_car.add_rider(r)
                #print("Moved 1 Down!")
                if best_car.total_workers() > (fc.total_workers()  - 2):
                    less_full_cars_with_extra_seat.remove(best_car)
                removed_riders.append(r)

        # Now remove the riders from the fuller car that got reassigned . . .
        if (len(removed_riders) > 0):
            ret_val.remove(fc)
            current_riders = fc.riders
            fc.num_seats_left = fc.capacity
            fc.riders = []
            fc.time_slot_ids = set(fc.driver.time_slot_ids)
            for r in current_riders:
                if (r not in removed_riders):
                    fc.add_rider(r)

    return ret_val



"""
A School is fundamentally a set of Teachers. A school has an id,
a list of its teachers, and a work dictionary. Work tracks available
work slots at a school. An entry 1 : 10 means that there are 10 slots
of work available at time 1. As cars get assigned to schools at specific
times, this dictionary is updated to reflect the number of remaining openings.
"""
class School:
    def __init__(self, school_id, teachers):
        self.school_id = school_id
        self.teachers = teachers
        self.work = self.compute_work()

    def compute_work(self):
        work = {}
        # for now, a teacher may only be assigned a single helper . . .
        # TODO: increment work by # of students teacher could use at this time
        for t in self.teachers:
            for time in t.time_slot_ids:
                if time not in work:
                    work[time] = 1
                else:
                    work[time] = work[time] + 1
        return work

    """ given a list of times when workers can work and the size of each work-group, return the
    subset of the input of times that this school could use a work-group of size size """
    def compute_work_slots(self, size, worker_times):
        work_times = {}
        for w in worker_times:
            if (w in self.work) and (self.work[w] >= size):
                work_times[w] = int(floor(self.work[w] / size))
        return work_times

    def __repr__(self):
        return "\n" + self.school_id + str(self.teachers)

    def __eq__(self, other):
        if isinstance(other, School):
            return (self.school_id == other.school_id)
        else:
            return False

    def __hash__(self):
        return hash(self.school_id)

"""
Given cars, schools, and work_group_size, build the bipartite graph and
run HopcroftKarp to determine maximal matching between cars and school
work-blocks.
"""
def run_matching(cars, schools, size):
    global g_assignments
    global g_assigned_cars
    global g_unassigned_cars

    # determine the cars relevant for this round
    round_cars = []
    for c in cars:
        if c.total_workers() == size:
            round_cars.append(c)

    # get the set of worker_times for this round
    relevant_time_slots = set()
    for c in round_cars:
        relevant_time_slots.update(c.time_slot_ids)

    # Create a dictionary relating school_id to list of times where "size" workers are needed
    # by the school
    school_work_times = {}
    for s in schools:
        school_work_times[s.school_id] = s.compute_work_slots(size, relevant_time_slots)

    #graph = {"a" : ["1","2","3"], "b" : ["3","4","5"], "c" : ["1"]}
    #print(str(HopcroftKarp(graph).maximum_matching()))

    # Build bipartite graph. Column 1 is car_ids. Column 2 is school_id_slot#.
    graph = {}
    for c in round_cars:
        list_of_compatible_work_blocks = []
        for school in school_work_times:
            for time in school_work_times[school]:
                if time in c.time_slot_ids:
                    #list_of_compatible_work_blocks.append(school + "_" + str(time) + "*") # one work block for school of this size at each time
                    for i in range(0, school_work_times[school][time]):
                        list_of_compatible_work_blocks.append(school + "_" + str(time) + "*" + str(i + 1))
        if (len(list_of_compatible_work_blocks) > 0):
            graph[c.car_id] = list_of_compatible_work_blocks

    # determine the maximum matching between cars and schools
    result = HopcroftKarp(graph).maximum_matching()

    # Update schools' work to account for taken slots
    for key in result:
        #TODO verify that student email may never contain '_'
        if key.rfind('_') != -1:
            # it's a school_work_item
            school_id = key[:key.rfind('_')]
            time_slot = int(key[key.rfind('_') + 1 : key.rfind('*')])
            for s in schools:
                if s.school_id == school_id:
                    s.work[time_slot] -= size
        else:
            # it's a car_id. Add this to g_assignments
            g_assignments[key] = result[key]

    # Track (Un)assigned Cars
    unassigned_cars = []
    assigned_cars = []
    for c in round_cars:
        if c.car_id not in result:
            unassigned_cars.append(c)
        else:
            assigned_cars.append(c)

    # try to push the unassigned cars down into lower rounds
    unassigned_cars = normalize_cars(cars, unassigned_cars, size)

    # print("Car_Size: " + str(size))
    # print("Unassigned Cars:" + str(len(unassigned_cars)))
    # print(str(unassigned_cars))
    #if (size == 3):
       # print("Assigned Cars:" + str(len(assigned_cars)))
       # print(str(assigned_cars))
       # print(schools)
    #print(result)

    g_assigned_cars += assigned_cars
    g_unassigned_cars += unassigned_cars

"""
In this method, we first build all the School objects.
This is accomplished by grouping teachers by school, then intializing a new
School object with the school's name and list of teachers.

Then we find the size of the biggest car, and run our matching algorithm
for all car sizes, starting at the biggest, and working our way down to 1.
"""
def create_schools_and_iterate_through_car_sizes(cars, teachers):
    global g_unassigned_cars
    global g_unassigned_riders
    global g_schools_final_state

    schools = create_schools(teachers)

    # determine biggest car size
    biggest_car = 0
    for c in cars:
        if c.total_workers() > biggest_car:
            biggest_car = c.total_workers()

    # run matching algorithm biggest_car times. Run matching
    # algorithm for all car sizes, starting with biggest cars first
    for i in range(biggest_car,0,-1):
        run_matching(cars, schools, i)


    # Experimentally run algorithm from scratch with remainder
    remaining_students = []
    remaining_students += g_unassigned_riders
    for c in g_unassigned_cars:
        remaining_students += c.riders
        remaining_students.append(c.driver)

    # reset these before matching again . . .
    g_unassigned_cars = []
    g_unassigned_riders = []

    cars = create_cars(remaining_students, g_MAX_RESTRICTION_V2, False)

    # determine biggest car size
    biggest_car = 0
    for c in cars:
        if c.total_workers() > biggest_car:
            biggest_car = c.total_workers()

    # run matching algorithm biggest_car times. Run matching
    # algorithm for all car sizes, starting with biggest cars first
    for i in range(biggest_car,0,-1):
        run_matching(cars, schools, i)

    #END Experimental

    g_schools_final_state = schools

"""
Given set of teachers, return list of schools
"""
def create_schools(teachers = None):
    if teachers == None:
        return None

    teacher_sets = {}
    for t in teachers:
        if t.teacher_school in teacher_sets:
            teacher_sets[t.teacher_school].append(t)
        else:
            teacher_sets[t.teacher_school] = [t,]

    schools = []
    for school in teacher_sets:
        schools.append(School(school, teacher_sets[school]))

    return schools


"""
The purpose of this function is to verify that the result is feasible.
This includes checking the following:

1. Every car has enough seats for its workers.
2. Every student can work when they are assigned to work
"""
def verify_feasibility_of_solution():
    # g_best_solution = (g_assignments, g_assigned_cars, g_unassigned_cars, g_unassigned_riders, count + len(g_unassigned_riders))
    schools = create_schools(g_teachers)
    for car in g_best_solution[1]:
        # check to see that car can carry all its passengers
        if (len(car.riders) > car.capacity):
            return "NOT FEASIBLE"
        school_assignment = g_best_solution[0][car.car_id]
        school_id = school_assignment[:school_assignment.rfind('_')]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        # check to see that there's a job for all of these workers
        for s in schools:
            if (s.school_id == school_id):
                s.work[time_slot] = s.work[time_slot] - car.total_workers()
                if s.work[time_slot] < 0:
                    return "NOT FEASIBLE"
        # check to see that all the members of a car can work when they're assigned to
        for r in car.riders:
            if time_slot not in r.time_slot_ids:
                return "NOT FEASIBLE"
            if time_slot not in car.driver.time_slot_ids:
                return "NOT FEASIBLE"
    # passed all checks
    return "Feasibility Verified!"

def write_results_to_excel_workbook():
    workbook = xlsxwriter.Workbook('Schedule.xlsx')
    bold = workbook.add_format({'bold': True})

    teacher_assignments = create_teacher_assignments(g_best_solution[0], g_best_solution[1])
    cars = g_best_solution[1]

    students_worksheet = workbook.add_worksheet('Assignments')
    cols = ['student_id', 'car_id', 'start_time', 'school_id', 'teacher_id', 'teacher_room']
    for i,val in enumerate(cols):
        students_worksheet.write(0,i,val, bold)
    row_counter = 1
    for c in cars:
        school_assignment = g_best_solution[0][c.car_id]
        school_id = school_assignment[:school_assignment.rfind('_')]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        workers = [c.driver,] + c.riders
        for w in workers:
            values = [w.student_id, c.car_id, extract_readable_start_time(time_slot), school_id, teacher_assignments[w.student_id].teacher_id, teacher_assignments[w.student_id].room_number]
            for i,val in enumerate(values):
                students_worksheet.write(row_counter,i,val)
            row_counter += 1

    cars_worksheet = workbook.add_worksheet('Cars')
    cols = ['driver_id', 'riders', 'start_time', 'school', 'seats_remaining']
    for i,val in enumerate(cols):
        cars_worksheet.write(0,i,val,bold)
    row_counter = 1
    for c in cars:
        school_assignment = g_best_solution[0][c.car_id]
        school_id = school_assignment[:school_assignment.rfind('_')]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        values = [c.car_id,str(c.riders),extract_readable_start_time(time_slot), school_id, c.num_seats_left]
        for i,val in enumerate(values):
            cars_worksheet.write(row_counter,i,val)
        row_counter += 1

    teachers_worksheet = workbook.add_worksheet('Teachers Assigned')
    cols = ['teacher_id', 'start_time', 'student_id(s)']
    for i,val in enumerate(cols):
        teachers_worksheet.write(0,i,val,bold)
    row_counter = 1

    teacher_helpers = {}    # map teachers to dictionaries of {time_slot : helpers}
    for student_id in teacher_assignments:
        t = teacher_assignments[student_id]
        if t not in teacher_helpers:
            teacher_helpers[t] = {}

        # find what time this student works
        car = None
        for c in cars:
            if c.driver.student_id == student_id:
                car = c
            else:
                for s in c.riders:
                    if s.student_id == student_id:
                        car = c
                        break
            if car != None:
                break
        school_assignment = g_best_solution[0][car.car_id]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        if time_slot in teacher_helpers[t]:
            teacher_helpers[t][time_slot].append(student_id)
        else:
            teacher_helpers[t][time_slot] = [student_id, ]

    for t in teacher_helpers:
        for time_slot in teacher_helpers[t]:
            values = [t.teacher_id, extract_readable_start_time(time_slot), str(teacher_helpers[t][time_slot])]
            for i,val in enumerate(values):
                teachers_worksheet.write(row_counter, i, val)
            row_counter += 1

    unassigned_worksheet = workbook.add_worksheet('Unassigned_Workers')
    cols = ['student_id', 'is_driver', 'work_times']
    for i,val in enumerate(cols):
        unassigned_worksheet.write(0,i,val,bold)
    row_counter = 1

    unassigned_workers = []
    for c in g_best_solution[2]:
        unassigned_workers.append(c.driver)
        unassigned_workers += c.riders
    unassigned_workers += g_best_solution[3]

    for w in unassigned_workers:
        readable_time_slots = []
        for time_slot in w.time_slot_ids:
            readable_time_slots.append(extract_readable_start_time(time_slot))
        values = [w.student_id, w.is_driver, str(readable_time_slots)]
        for i,val in enumerate(values):
            unassigned_worksheet.write(row_counter,i,val)
        row_counter += 1

    available_work_worksheet = workbook.add_worksheet('Unassigned_Work')
    cols = ['school_id', 'start_time', 'num_positions']
    for i,val in enumerate(cols):
        available_work_worksheet.write(0,i,val,bold)
    row_counter = 1

    for school in g_schools_final_state:
        for time in school.work:
            if school.work[time] > 0:
                available_work_worksheet.write(row_counter, 0, school.school_id)
                available_work_worksheet.write(row_counter, 1, extract_readable_start_time(time))
                available_work_worksheet.write(row_counter, 2, str(school.work[time]))
                row_counter += 1

    available_slots_worksheet = workbook.add_worksheet('Unassigned_Teacher_Slots')
    cols = ['teacher_id', 'school_id', 'num_helpers_assigned', 'unassigned_slots']
    for i,val in enumerate(cols):
        available_slots_worksheet.write(0,i,val,bold)
    row_counter = 1


    for t in g_teachers:
        all_time_slots = list(t.time_slot_ids)
        if t in teacher_helpers:
            for time_slot in teacher_helpers[t]:
                all_time_slots.remove(time_slot) #we assume one helper for now TODO: update this . . .
        readable_remaining_time_slots = []
        for time_slot in all_time_slots:
            readable_remaining_time_slots.append(extract_readable_start_time(time_slot))
        values = [t.teacher_id, t.teacher_school, t.num_helpers, str(readable_remaining_time_slots)]
        for i,val in enumerate(values):
            available_slots_worksheet.write(row_counter, i, val)
        row_counter += 1

    workbook.close()

    return None

"""
Given a dictionary mapping cars to schools at specific times,
and a list of all assigned cars, return a dictionary mapping students to teachers
"""
def create_teacher_assignments(car_assignments, cars):
    ret_val = {}
    for c in cars:
        school_assignment = car_assignments[c.car_id]
        school_id = school_assignment[:school_assignment.rfind('_')]
        time_slot = int(school_assignment[school_assignment.rfind('_') + 1 : school_assignment.rfind('*')])
        school = None
        for s in g_schools_final_state:
            if s.school_id == school_id:
                school = s
                break
        # first shuffle the teachers, then sort into ascending order based on num_helpers
        # this makes teachers with least help get considered first and makes it random in case
        # there's a tie
        random.shuffle(school.teachers)
        workers = [c.driver,] + c.riders
        for w in workers:
            school.teachers.sort(key=lambda x: x.num_helpers, reverse=False)
            for t in school.teachers:
                # TODO: support a teacher being allowed to have multiple helpers at a given time
                if time_slot in t.time_slot_ids and time_slot not in t.assigned_time_slot_ids:
                    ret_val[w.student_id] = t
                    t.num_helpers = t.num_helpers + 1
                    t.assigned_time_slot_ids.append(time_slot)
                    break

    return ret_val

def extract_readable_start_time(time_slot):
    days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']
    day_index = int(time_slot/48)
    hour = (time_slot%48) # time_slot could be 0 through 238
    token_one = days[day_index]

    token_two = ''
    hr_output = 0
    if hour > 23:
        hour_output = int((hour - 24) / 2)
    else:
        hour_output = int(hour/2)
    if (hour_output == 0):
        hour_output = 12
    token_two = str(hour_output)

    token_three = ''
    if (hour%2) == 0:
        token_three = ':00'
    else:
        token_three = ':30'

    token_four = ''
    if hour > 23:
        token_four = 'p.m.'
    else:
        token_four = 'a.m.'

    return token_one + ' ' + token_two + token_three + token_four

if __name__ == '__main__':
    global g_students
    global g_teachers
    global g_assignments
    global g_assigned_cars
    global g_unassigned_cars
    global g_MAX_RESTRICTION
    global g_MAX_RESTRICTION_V2
    global g_best_solution
    g_best_solution = None
    for i in range(0,9):
        for j in range(0,10):
            g_assignments = {}
            g_unassigned_cars = []
            g_assigned_cars = []
            g_students = readInStudentsFile()
            g_teachers = readInTeachersFile()
            g_MAX_RESTRICTION = 4 + int(i/3)    # try flexibility values 4,5,6
            g_MAX_RESTRICTION_V2 = 7 + (i%3)    # with re-run values 7,8,9
            create_schools_and_iterate_through_car_sizes(create_cars(g_students, g_MAX_RESTRICTION), g_teachers)
            #print("# Unassigned Riders: " + str(len(g_unassigned_riders)))
            #print("# Unassigned Cars: " + str(len(g_unassigned_cars)))
            count = 0
            for c in g_assigned_cars:
                count += c.total_workers()
            #print("# Assigned Workers: " + str(count))
            count = 0
            for c in g_unassigned_cars:
                count += c.total_workers()
            #print("# Unassigned Workers: " + str(count))
            #print("# Assigned Cars: " + str(len(g_assignments)))
            #print("Assignments: " + str(g_assignments))
            #print("Cars: " + str(g_assigned_cars))
            if (g_best_solution == None) or ((count + len(g_unassigned_riders)) < g_best_solution[4]):
                g_best_solution = (g_assignments, g_assigned_cars, g_unassigned_cars, g_unassigned_riders, count + len(g_unassigned_riders))
    print(verify_feasibility_of_solution())
    write_results_to_excel_workbook()

"""
-----------------------------------Unused Code Below This Point------------------------------------------------

def run_hopcroft_karp(index_list, teacher_compatabilities):
    global g_cur_max_flow
    # Build the bipartite graph
    graph = {}

    for i in range(0, len(teacher_compatabilities)):
        for j in range(0, len(teacher_compatabilities[i][index_list[i]])):
            teacher_interval_node_name = g_teachers[i].teacher_id + str(teacher_compatabilities[i][index_list[i]][j])
            candidate_workers = ()
            for student in g_students:
                if teacher_compatabilities[i][index_list[i]][j] in student.time_slot_ids:
                    candidate_workers += (student.student_id,)
            if len(candidate_workers) > 0:
                graph[teacher_interval_node_name] = set(candidate_workers)

    result = HopcroftKarp(graph).maximum_matching()
    g_cur_max_flow = (result, (len(result) / 2))

    fo = open("hopcroft_karp_result", "wb")
    fo.write((str(result)).encode("utf-8"))
    fo.close()

    return result


Here, we wish to accept an index_list and a list of teacher_compatabilities.
We will run ford fulkerson by building a graph based on the current set of
compatability sets (compatability_set_i at teacher_compatabilities[i][index_list[i]])
and the set of students (which doesn't change). Finally, we will return the max
flow for the Graph and the string specifying which edges/flows are involved in the
solution

def run_ford_fulkerson(index_list, teacher_compatabilities):
    global g_cur_max_flow
    global g_counter

    g_counter += 1
    if (g_counter % 100) == 0:
        print(str(g_counter) + ":" + str(g_cur_max_flow))

    edge_count = 0
    g = FlowNetwork()
    g.AddVertex('s')
    g.AddVertex('t')
    for student in g_students:
        g.AddVertex(student.student_id)
        g.AddEdge(student.student_id, 't', 1)
        edge_count += 1
    for i in range(0, len(teacher_compatabilities)):
        for j in range(0, len(teacher_compatabilities[i][index_list[i]])):
            teacher_interval_node_name = g_teachers[i].teacher_id + str(teacher_compatabilities[i][index_list[i]][j])
            g.AddVertex(teacher_interval_node_name)
            g.AddEdge('s', teacher_interval_node_name, 1)
            edge_count += 1
            for student in g_students:
                if teacher_compatabilities[i][index_list[i]][j] in student.time_slot_ids:
                    g.AddEdge(teacher_interval_node_name,student.student_id, 1)
                    edge_count += 1
    print("Edge Count: " + str(edge_count))
    max_flow_vals = g.MaxFlow('s', 't')
    if max_flow_vals[1] > g_cur_max_flow[1]:
        g_cur_max_flow = max_flow_vals


In this function, we maintain an index_list and a max_index list of length
equal to len(teacher_compatibilities). Each entry in index_list tracks the index
of the compatability set the current enumeration is using in the corresponding list of
compatability sets. Furthermore, max_index_list tracks the maximum allowed index at
the corresonding positions in index_list.

def enumerate_all_compatibility_set_combinations(teacher_compatabilities):
    index_list = []
    max_index_list = []
    for i in range(0,len(teacher_compatabilities)):
        index_list.append(0)
        max_index_list.append(len(teacher_compatabilities[i]) - 1)

    #run_ford_fulkerson(index_list,teacher_compatabilities)
    run_hopcroft_karp(index_list, teacher_compatabilities)
    while update_element(index_list, max_index_list, len(index_list) - 1) == True:
        run_ford_fulkerson(index_list, teacher_compatabilities)


A Helper Function for enumarate_all_compatability_set_combinations
Here, we update the index_list to represent the next permutation of
compatibility set selections. max_index_list is used to help.

def update_element(index_list, max_index_list, start_index):
    if (start_index == 0) and (index_list[0] == max_index_list[0]):
        # we have finished all enumerations
        return False
    elif index_list[start_index] != max_index_list[start_index]:
        # just add one at start_index and return True
        index_list[start_index] = index_list[start_index] + 1
        return True
    else:
        # index_list[start_index] == max_index_list[start_index]
        index_list[start_index] = 0
        return update_element(index_list, max_index_list, start_index - 1)


Here, we wish to accept a list of time_intervals I = [1,2,23,55, . . .]
and return a list of all maximal compatibility sets derived from this input.
This will be done by applying the "Ramey-Zig-Zag" algorithm.
Definition of maximal compatibility set:
Let a teacher T have some set I = {I1,I2,I3...In} of need-help-intervals.
Then, we define a compatibility set to be any set of intervals such that
no two intervals in the set overlap. Furthermore, a maximal compatibility set
adds the constraint that there does not exist an interval in I that does not
overlap with some interval in the compatibilty set.

def compute_all_maximal_compatibility_sets(time_intervals):
    solution = []
    SET_HOUR = []
    SET_THIRTY = []
    for num in time_intervals:
        if (num % 2) == 1:
            SET_HOUR.append(num)
        else:
            SET_THIRTY.append(num)
    if (len(SET_HOUR) == 0) or (len(SET_THIRTY) == 0):
        (solution.append(SET_HOUR)) if (len(SET_THIRTY) == 0) else (solution.append(SET_THIRTY))
        return solution

    solution.append(SET_HOUR)
    solution.append(SET_THIRTY)

    for j in range(0,2):
        index = 0
        while not(is_compatible_with_earlier_interval_in_each_list(solution[j][index], SET_HOUR, SET_THIRTY)):
            zig_count = 1
            while (True):
                s = [(solution[j][index]),]
                for i in range(0,zig_count):
                    target_val = s[len(s) - 1]
                    was_zag_point_found = False
                    for k in solution[(i + j + 1) % 2]:
                        if k > (target_val + 1):
                            was_zag_point_found = True
                            s.append(k)
                            if i != (zig_count - 1):
                                break
                    if was_zag_point_found == False:
                        s = []
                        break
                if len(s) == 0:
                    break
                else:
                    solution.append(s)
                zig_count += 1

            if (len(solution[j]) - 1) > index:
                index += 1
            else:
                break

    return solution

A Helper Function:
Accepts two lists of times along with a test_value.
If there does not exist a prior entry from each list with
which test_value is compatible, return True. Else return False.

def is_compatible_with_earlier_interval_in_each_list(test_val, list_one, list_two):
    list_one_contains_compatible_previous_entry = False
    list_two_contains_compatible_previous_entry = False

    for i in list_one:
        if (i < test_val - 1):
           list_one_contains_compatible_previous_entry = True

    for i in list_two:
        if (i < test_val - 1):
            list_two_contains_compatible_previous_entry = True

    return (list_one_contains_compatible_previous_entry and list_two_contains_compatible_previous_entry)
"""