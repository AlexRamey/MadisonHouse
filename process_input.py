# Alex Ramey (abr8xq)

# process_input.py is intended to serve as the middle layer in this solution.
# It accepts that list of teachers and the list of students generated by read_input.py,
# and does further processing before repeatedly invoking HopcroftKarp, the lowest
# layer, and keep track of the optimal solutions.

from hopcroftkarp import HopcroftKarp
from read_input import Student, Teacher, readInStudentsFile, readInTeachersFile
from sys import maxsize
from math import floor

global g_students
global g_teachers
global g_assignments
global g_assigned_cars
global g_unassigned_riders
global g_unassigned_cars

"""
A car is identified by its driver. It has a capacity, list of riders, number
of seats left, and list of time_slot_ids that is initially equal to its driver's
list of availability. As riders are added, their availability is intersected with
the car's availability to determine the new availability.
"""
class Car:
    def __init__(self, driver):
        # constants . . .
        self.car_id = driver.student_id
        self.capacity = driver.num_seats    # doesn't include the driver
        self.driver = driver
        # state variables . . .
        self.riders = []
        self.num_seats_left = self.capacity
        self.time_slot_ids = set(driver.time_slot_ids)

    def add_rider(self, student):
        self.riders.append(student)
        self.num_seats_left -= 1
        self.time_slot_ids = self.time_slot_ids.intersection(set(student.time_slot_ids))

    def total_workers(self):
        return self.capacity - self.num_seats_left + 1

    def __repr__(self):
        #return "\n" + self.car_id + ":" + str(len(self.riders)) + "/" + str(self.capacity) + ":" + str(self.riders) + ":" + str(list(self.time_slot_ids))
        return self.car_id + ":" + str(self.riders)

    def __eq__(self, other):
        if isinstance(other, Car):
            return (self.car_id == other.other_id)
        else:
            return False

    def __hash__(self):
        return hash(self.car_id)

"""
Strategy: Start with a set of empty cars and a set of unassigned riders. Place riders into cars they restrict the least.
A car's working time set may never drop below cardinality min(MAX_RESTRICTION,inital size of driver's working time set),
so we can not add a rider to a car that would violate this.

A higher MAX_RESTRICTION value favors car flexibility at the expense of leaving some riders behind.
A lower MAX_RESTRICTION value favor packing in as many riders as possible at the expense of creating some
inflexible cars that may be harder to match in the next phase.

If no compatible cars exist, we iterate through all riders and see if swapping this rider with any given
rider would restrict a car less. If so, we swap these two riders. If not, we add the rider to the no-ride set.
"""
def create_cars(students, MAX_RESTRICTION = 5):
    global g_unassigned_riders

    eagles = []
    riders = []
    drivers = []

    for s in students:
        if s.is_driver == True and s.num_seats == 0:
            eagles.append(s)
        elif s.is_driver == True:
            drivers.append(s)
        else:
            riders.append(s)
    print("Eagles: " + str(len(eagles)) + ", Drivers: " + str(len(drivers)) + ", Riders: " + str(len(riders)))

    cars = []
    for d in drivers:
        cars.append(Car(d))

    # print(str(len(cars)))

    unassigned_riders = []
    assigned_riders = []

    riders.sort(key=lambda x: len(x.time_slot_ids), reverse=False)

    for r in riders:
        best_car = None
        lowest_restriction = maxsize
        for c in cars:
            restriction = compute_restriction(c,r,MAX_RESTRICTION)
            if restriction <= lowest_restriction and restriction != maxsize:
                if (not ((restriction == lowest_restriction) and (best_car.num_seats_left >= c.num_seats_left))):
                    lowest_restriction = restriction
                    best_car = c

        if best_car != None:
            best_car.add_rider(r)
            assigned_riders.append(r)
        else:
            #TODO See if there's a better way to handle this
            unassigned_riders.append(r)

    print("Number of Unassigned Riders: " + str(len(unassigned_riders)))
    print("Unassigned Riders: " + str(unassigned_riders))
    #print(cars)

    # Track the unassigned riders
    g_unassigned_riders = unassigned_riders

    for e in eagles:
        cars.append(Car(e))

    return cars

"""
Given a car, student, and MAX_RESTRICTION value, determine how many time_slots
this student would remove from the car's availability if they were added as a rider.
If the restriction level is too high or the car is already full, return maxsize
(indicating infinite restrction). Otherwise, return the actual restriction value.
"""
def compute_restriction(car, student, MAX_RESTRICTION):
    MAX_RESTRICTION = min(MAX_RESTRICTION, len(car.time_slot_ids))
    restriction = len(car.time_slot_ids) - len(car.time_slot_ids.intersection(set(student.time_slot_ids)))

    if ((len(car.time_slot_ids) - restriction) < MAX_RESTRICTION) or (car.num_seats_left == 0):
        return maxsize
    else:
        return restriction

"""
A School is fundamentally a set of Teachers. A school has an id,
a list of its teachers, and a work dictionary. Work tracks available
work slots at a school. An entry 1 : 10 means that there are 10 slots
of work available at time 1. As cars get assigned to schools at specific
times, this dictionary is updated to reflect the number of remaining openings.
"""
class School:
    def __init__(self, school_id, teachers):
        self.school_id = school_id
        self.teachers = teachers
        self.work = self.compute_work()

    def compute_work(self):
        work = {}
        for t in self.teachers:
            for time in t.time_slot_ids:
                if time not in work:
                    work[time] = 1
                else:
                    work[time] = work[time] + 1
        return work

    """ given a list of times when workers can work and the size of each work-group, return the
    subset of the input of times that this school could use a work-group of size size """
    def compute_work_slots(self, size, worker_times):
        work_times = {}
        for w in worker_times:
            if (w in self.work) and (self.work[w] >= size):
                work_times[w] = int(floor(self.work[w] / size))
        return work_times

    def __repr__(self):
        return "\n" + self.school_id + str(self.teachers)

    def __eq__(self, other):
        if isinstance(other, School):
            return (self.school_id == other.school_id)
        else:
            return False

    def __hash__(self):
        return hash(self.school_id)

"""
Given cars, schools, and work_group_size, build the bipartite graph and
run HopcroftKarp to determine maximal matching between cars and school
work-blocks.
"""
def run_matching(cars, schools, size):
    global g_assignments
    global g_assigned_cars
    global g_unassigned_cars

    # determine the cars relevant for this round
    round_cars = []
    for c in cars:
        if c.total_workers() == size:
            round_cars.append(c)

    # get the set of worker_times for this round
    relevant_time_slots = set()
    for c in round_cars:
        relevant_time_slots.update(c.time_slot_ids)

    # Create a dictionary relating school_id to list of times where "size" workers are needed
    # by the school
    school_work_times = {}
    for s in schools:
        school_work_times[s.school_id] = s.compute_work_slots(size, relevant_time_slots)

    #graph = {"a" : ["1","2","3"], "b" : ["3","4","5"], "c" : ["1"]}
    #print(str(HopcroftKarp(graph).maximum_matching()))

    # Build bipartite graph. Column 1 is car_ids. Column 2 is school_id_slot#.
    graph = {}
    for c in round_cars:
        list_of_compatible_work_blocks = []
        for school in school_work_times:
            for time in school_work_times[school]:
                if time in c.time_slot_ids:
                    #list_of_compatible_work_blocks.append(school + "_" + str(time) + "*") # one work block for school of this size at each time
                    for i in range(0, school_work_times[school][time]):
                        list_of_compatible_work_blocks.append(school + "_" + str(time) + "*" + str(i + 1))
        if (len(list_of_compatible_work_blocks) > 0):
            graph[c.car_id] = list_of_compatible_work_blocks

    # determine the maximum matching between cars and schools
    result = HopcroftKarp(graph).maximum_matching()

    # Update schools' work to account for taken slots
    for key in result:
        #TODO verify that student email may never contain '_'
        if key.rfind('_') != -1:
            # it's a school_work_item
            school_id = key[:key.rfind('_')]
            time_slot = int(key[key.rfind('_') + 1 : key.rfind('*')])
            for s in schools:
                if s.school_id == school_id:
                    s.work[time_slot] -= size
        else:
            # it's a car_id. Add this to g_assignments
            g_assignments[key] = result[key]

    # Track (Un)assigned Cars
    unassigned_cars = []
    assigned_cars = []
    for c in round_cars:
        if c.car_id not in result:
            unassigned_cars.append(c)
        else:
            assigned_cars.append(c)

    #print("Car_Size: " + str(size))
    #print("Unassigned Cars:" + str(len(unassigned_cars)))
    # print(str(unassigned_cars))
    #if (size == 3):
       # print("Assigned Cars:" + str(len(assigned_cars)))
       # print(str(assigned_cars))
       # print(schools)
    #print(result)

    g_assigned_cars += assigned_cars
    g_unassigned_cars += unassigned_cars

"""
In this method, we first build all the School objects.
This is accomplished by grouping teachers by school, then intializing a new
School object with the school's name and list of teachers.

Then we find the size of the biggest car, and run our matching algorithm
for all car sizes, starting at the biggest, and working our way down to 1.
"""
def create_schools_and_iterate_through_car_sizes(cars, teachers):
    global g_unassigned_cars
    global g_unassigned_riders

    teacher_sets = {}
    for t in teachers:
        if t.teacher_school in teacher_sets:
            teacher_sets[t.teacher_school].append(t)
        else:
            teacher_sets[t.teacher_school] = [t,]

    schools = []
    for school in teacher_sets:
        schools.append(School(school, teacher_sets[school]))

    # determine biggest car size
    biggest_car = 0
    for c in cars:
        if c.total_workers() > biggest_car:
            biggest_car = c.total_workers()

    # run matching algorithm biggest_car times. Run matching
    # algorithm for all car sizes, starting with biggest cars first
    for i in range(biggest_car,0,-1):
        run_matching(cars, schools, i)

    """
    # Experimentally run algorithm from scratch with remainder
    remaining_students = []
    remaining_students += g_unassigned_riders
    for c in g_unassigned_cars:
        remaining_students += c.riders
        remaining_students.append(c.driver)

    # reset these before matching again . . .
    g_unassigned_cars = []
    g_unassigned_riders = []

    cars = create_cars(remaining_students, 1)

    # determine biggest car size
    biggest_car = 0
    for c in cars:
        if c.total_workers() > biggest_car:
            biggest_car = c.total_workers()

    # run matching algorithm biggest_car times. Run matching
    # algorithm for all car sizes, starting with biggest cars first
    for i in range(biggest_car,0,-1):
        run_matching(cars, schools, i)

    #END Experimental
    """

if __name__ == '__main__':
    global g_students
    global g_teachers
    global g_assignments
    global g_assigned_cars
    global g_unassigned_cars
    g_assignments = {}
    g_unassigned_cars = []
    g_assigned_cars = []
    g_students = readInStudentsFile()
    g_teachers = readInTeachersFile()
    create_schools_and_iterate_through_car_sizes(create_cars(g_students), g_teachers)
    print("# Unassigned Riders: " + str(len(g_unassigned_riders)))
    print("# Unassigned Cars: " + str(len(g_unassigned_cars)))
    count = 0
    for c in g_unassigned_cars:
        count += c.total_workers()
    print("# Unassigned Workers: " + str(count))
    print("# Assigned Cars: " + str(len(g_assignments)))
    count = 0
    for c in g_assigned_cars:
        count += c.total_workers()
    print("# Assigned Workers: " + str(count))
    print("Assignments: " + str(g_assignments))
    print("Cars: " + str(g_assigned_cars))

"""
-----------------------------------Unused Code Below This Point------------------------------------------------

def run_hopcroft_karp(index_list, teacher_compatabilities):
    global g_cur_max_flow
    # Build the bipartite graph
    graph = {}

    for i in range(0, len(teacher_compatabilities)):
        for j in range(0, len(teacher_compatabilities[i][index_list[i]])):
            teacher_interval_node_name = g_teachers[i].teacher_id + str(teacher_compatabilities[i][index_list[i]][j])
            candidate_workers = ()
            for student in g_students:
                if teacher_compatabilities[i][index_list[i]][j] in student.time_slot_ids:
                    candidate_workers += (student.student_id,)
            if len(candidate_workers) > 0:
                graph[teacher_interval_node_name] = set(candidate_workers)

    result = HopcroftKarp(graph).maximum_matching()
    g_cur_max_flow = (result, (len(result) / 2))

    fo = open("hopcroft_karp_result", "wb")
    fo.write((str(result)).encode("utf-8"))
    fo.close()

    return result


Here, we wish to accept an index_list and a list of teacher_compatabilities.
We will run ford fulkerson by building a graph based on the current set of
compatability sets (compatability_set_i at teacher_compatabilities[i][index_list[i]])
and the set of students (which doesn't change). Finally, we will return the max
flow for the Graph and the string specifying which edges/flows are involved in the
solution

def run_ford_fulkerson(index_list, teacher_compatabilities):
    global g_cur_max_flow
    global g_counter

    g_counter += 1
    if (g_counter % 100) == 0:
        print(str(g_counter) + ":" + str(g_cur_max_flow))

    edge_count = 0
    g = FlowNetwork()
    g.AddVertex('s')
    g.AddVertex('t')
    for student in g_students:
        g.AddVertex(student.student_id)
        g.AddEdge(student.student_id, 't', 1)
        edge_count += 1
    for i in range(0, len(teacher_compatabilities)):
        for j in range(0, len(teacher_compatabilities[i][index_list[i]])):
            teacher_interval_node_name = g_teachers[i].teacher_id + str(teacher_compatabilities[i][index_list[i]][j])
            g.AddVertex(teacher_interval_node_name)
            g.AddEdge('s', teacher_interval_node_name, 1)
            edge_count += 1
            for student in g_students:
                if teacher_compatabilities[i][index_list[i]][j] in student.time_slot_ids:
                    g.AddEdge(teacher_interval_node_name,student.student_id, 1)
                    edge_count += 1
    print("Edge Count: " + str(edge_count))
    max_flow_vals = g.MaxFlow('s', 't')
    if max_flow_vals[1] > g_cur_max_flow[1]:
        g_cur_max_flow = max_flow_vals


In this function, we maintain an index_list and a max_index list of length
equal to len(teacher_compatibilities). Each entry in index_list tracks the index
of the compatability set the current enumeration is using in the corresponding list of
compatability sets. Furthermore, max_index_list tracks the maximum allowed index at
the corresonding positions in index_list.

def enumerate_all_compatibility_set_combinations(teacher_compatabilities):
    index_list = []
    max_index_list = []
    for i in range(0,len(teacher_compatabilities)):
        index_list.append(0)
        max_index_list.append(len(teacher_compatabilities[i]) - 1)

    #run_ford_fulkerson(index_list,teacher_compatabilities)
    run_hopcroft_karp(index_list, teacher_compatabilities)
    while update_element(index_list, max_index_list, len(index_list) - 1) == True:
        run_ford_fulkerson(index_list, teacher_compatabilities)


A Helper Function for enumarate_all_compatability_set_combinations
Here, we update the index_list to represent the next permutation of
compatibility set selections. max_index_list is used to help.

def update_element(index_list, max_index_list, start_index):
    if (start_index == 0) and (index_list[0] == max_index_list[0]):
        # we have finished all enumerations
        return False
    elif index_list[start_index] != max_index_list[start_index]:
        # just add one at start_index and return True
        index_list[start_index] = index_list[start_index] + 1
        return True
    else:
        # index_list[start_index] == max_index_list[start_index]
        index_list[start_index] = 0
        return update_element(index_list, max_index_list, start_index - 1)


Here, we wish to accept a list of time_intervals I = [1,2,23,55, . . .]
and return a list of all maximal compatibility sets derived from this input.
This will be done by applying the "Ramey-Zig-Zag" algorithm.
Definition of maximal compatibility set:
Let a teacher T have some set I = {I1,I2,I3...In} of need-help-intervals.
Then, we define a compatibility set to be any set of intervals such that
no two intervals in the set overlap. Furthermore, a maximal compatibility set
adds the constraint that there does not exist an interval in I that does not
overlap with some interval in the compatibilty set.

def compute_all_maximal_compatibility_sets(time_intervals):
    solution = []
    SET_HOUR = []
    SET_THIRTY = []
    for num in time_intervals:
        if (num % 2) == 1:
            SET_HOUR.append(num)
        else:
            SET_THIRTY.append(num)
    if (len(SET_HOUR) == 0) or (len(SET_THIRTY) == 0):
        (solution.append(SET_HOUR)) if (len(SET_THIRTY) == 0) else (solution.append(SET_THIRTY))
        return solution

    solution.append(SET_HOUR)
    solution.append(SET_THIRTY)

    for j in range(0,2):
        index = 0
        while not(is_compatible_with_earlier_interval_in_each_list(solution[j][index], SET_HOUR, SET_THIRTY)):
            zig_count = 1
            while (True):
                s = [(solution[j][index]),]
                for i in range(0,zig_count):
                    target_val = s[len(s) - 1]
                    was_zag_point_found = False
                    for k in solution[(i + j + 1) % 2]:
                        if k > (target_val + 1):
                            was_zag_point_found = True
                            s.append(k)
                            if i != (zig_count - 1):
                                break
                    if was_zag_point_found == False:
                        s = []
                        break
                if len(s) == 0:
                    break
                else:
                    solution.append(s)
                zig_count += 1

            if (len(solution[j]) - 1) > index:
                index += 1
            else:
                break

    return solution

A Helper Function:
Accepts two lists of times along with a test_value.
If there does not exist a prior entry from each list with
which test_value is compatible, return True. Else return False.

def is_compatible_with_earlier_interval_in_each_list(test_val, list_one, list_two):
    list_one_contains_compatible_previous_entry = False
    list_two_contains_compatible_previous_entry = False

    for i in list_one:
        if (i < test_val - 1):
           list_one_contains_compatible_previous_entry = True

    for i in list_two:
        if (i < test_val - 1):
            list_two_contains_compatible_previous_entry = True

    return (list_one_contains_compatible_previous_entry and list_two_contains_compatible_previous_entry)
"""